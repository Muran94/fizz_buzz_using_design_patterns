# 1. 高凝集
# → 関連するデータとロジックを単一のクラスにまとめることで、ロジックの重複に伴う様々なリスクを低減できる。
# → 今回のケースでは、高凝集にすることで得られる恩恵は少ないが、ありがちなのは、消費税を計算するためのロジックが、
# 適切なクラスに実装されていないために、同じようなロジックがあちこちに実装されてしまい、仕様変更時に、修正漏れに伴うバグが発生すること。
#
# 2. テスト駆動開発
# → 「レッド、グリーン、リファクタリング」のステップに分けて自動テストを実装することで、コードの品質を担保している。
# → また、テスト駆動開発によって、クラスのインターフェイスの「扱いやすさ」を検証しながら実装ができるため、インターフェイスの品質をある程度担保できるのもポイント。
#
class FizzBuzz
  # 1. カプセル化
  # → 必要なデータや、手続きのみを外部に公開することで、必要以上に、モジュール間同士の結合度を上げないようにしている。
  # → インスタンス変数@numberを読み取るためのゲッターメソッドを定義しているが、外部から参照する必要がないため、privateとして定義している。
  #
  private attr_reader :number

  # 1. 完全コンストラクタ
  # → 確実に正常なデータを持つインスタンスを生成することで、そのデータを扱うインスタンスメソッド内で、エラーが発生する確率を下げることができる。
  # → 今回は、コンストラクタ上部に、不正値を検知する仕組みを設け、不正値であった場合に例外を発生させている。
  # → 後続のプログラムが実行されず、不正なインスタンスが生成されるのを防ぐことができる。
  # → その他、例外を発生させる際には、適したクラスとメッセージを指定することで、デバッグが容易になるよう工夫している。
  #
  # 2. 不変オブジェクト
  # → インスタンスのデータの書き換えを許す構造にしてしまうと、ロジックを追うのが大変な上、意図しないバグを誘発する可能性もあるため、値の書き換えを許可しない「不変オブジェクト」を生成するよう定義。
  # → ※ コンストラクタ最終行に`freeze`と記述することで、インスタンスの中身の書き換えができない「不変オブジェクト」を生成できるようになる。
  #
  def initialize(number)
    raise ArgumentError, 'Argument `number` is required.'                          if number.nil?
    raise ArgumentError, 'Argument `number` must be an instance of Integer class.' unless number.is_a?(Integer)
    raise ArgumentError, 'Argument `number` must be greater than 0.'               unless number.positive?

    @number = number

    freeze
  end

  # 1. 早期return
  # → 早期returnを用いることで、条件判定部と、処理実行部を分けて記述することができ、コードの可読性の向上、また、コードの修正が容易になる。
  # → 特に、if文が何重にもネストしているようなプログラムは、早期returnを使ってリファクタリングするだけで可読性が大きく向上する。
  #
  # 2. 目的駆動命名
  # → 目的を表す命名にすることによって、プログラムの意図するところが明確になり、可読性が向上する。
  # → 今回のように、実世界で扱わないような曖昧な概念においては、目的を表す的確な表現が中々ないため、目的駆動命名による命名は難しい。そのため、仮で`to_s`としている。
  #
  def to_s
    return 'FizzBuzz' if (number % 15).zero?
    return 'Fizz'     if (number % 3).zero?
    return 'Buzz'     if (number % 5).zero?

    number.to_s
  end
end

# その他工夫している点
#
# 1. 後置if文を複数行記述する際に、if文の位置を揃えることで、ぱっと見で条件判定部と処理実行部の見分けが付くようにしている。
#
# 2. メソッドの戻り値の型はなるべく揃える。`to_s`メソッドにおいて、いずれの条件にもマッチしない場合、numberを返すが、
# numberに対して`to_s`メソッドを呼び出さないと、FizzBuzz#to_sは、文字列型、または、数値型のデータを返すようになる。
# バグの温床になるため、文字列型に揃えてデータを返すようにしている。
